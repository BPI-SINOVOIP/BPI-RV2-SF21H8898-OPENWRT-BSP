Index: hostapd-2022-01-16-cff80b4f/hostapd/config_file.c
===================================================================
--- hostapd-2022-01-16-cff80b4f.orig/hostapd/config_file.c
+++ hostapd-2022-01-16-cff80b4f/hostapd/config_file.c
@@ -3307,6 +3307,12 @@ static int hostapd_config_fill(struct ho
 			return 1;
 		}
 		conf->acs_num_scans = val;
+	} else if (os_strcmp(buf, "acs_chan_dynamic_select_enable") == 0) {
+		conf->acs_chan_dynamic_select_enable = atoi(pos);
+	} else if (os_strcmp(buf, "acs_chan_dynamic_select_period") == 0) {
+		conf->acs_chan_dynamic_select_period = atoi(pos);
+	} else if (os_strcmp(buf, "switch_channel_even_have_sta_enable") == 0) {
+		conf->switch_channel_even_have_sta_enable = atoi(pos);
 	} else if (os_strcmp(buf, "acs_chan_bias") == 0) {
 		if (hostapd_config_parse_acs_chan_bias(conf, pos)) {
 			wpa_printf(MSG_ERROR, "Line %d: invalid acs_chan_bias",
Index: hostapd-2022-01-16-cff80b4f/src/ap/acs.c
===================================================================
--- hostapd-2022-01-16-cff80b4f.orig/src/ap/acs.c
+++ hostapd-2022-01-16-cff80b4f/src/ap/acs.c
@@ -656,7 +656,7 @@ acs_find_ideal_chan_mode(struct hostapd_
 			 int n_chans, u32 bw,
 			 struct hostapd_channel_data **rand_chan,
 			 struct hostapd_channel_data **ideal_chan,
-			 long double *ideal_factor, u8 acs_chan_last_chan)
+			 long double *ideal_factor)
 {
 	struct hostapd_channel_data *chan, *adj_chan = NULL;
 	long double factor;
@@ -729,16 +729,6 @@ acs_find_ideal_chan_mode(struct hostapd_
 			}
 		}

-		if(acs_chan_last_chan && acs_chan_last_chan == chan->chan)
-		{
-			//current channel(last channel) is not busy enouth to have to change it
-			if(iface->conf->acs_chan_busy_per && (chan->interference_factor * 100) < iface->conf->acs_chan_busy_per)
-			{
-				*ideal_chan = chan;
-				break;
-			}
-		}
-
 		factor = 0;
 		if (acs_usable_chan(chan))
 			factor = chan->interference_factor;
@@ -809,15 +799,7 @@ acs_find_ideal_chan_mode(struct hostapd_
 		factor /= total_weight;

 		bias = NULL;
-		if(acs_chan_last_chan)
-		{
-			if(acs_chan_last_chan == chan->chan)
-			{
-				tmp_bias.channel = chan->chan;
-				tmp_bias.bias = (45 - iface->conf->acs_chan_bet_per) / 45.0;
-				bias = &tmp_bias;
-			}
-		} else if (iface->conf->acs_chan_bias) {
+		if (iface->conf->acs_chan_bias) {
 			for (k = 0; k < iface->conf->num_acs_chan_bias; k++) {
 				bias = &iface->conf->acs_chan_bias[k];
 				if (bias->channel == chan->chan)
@@ -927,23 +909,14 @@ bw_selected:
 		acs_chan_last_chan = atoi((char *)&buf);
 	}

-/* the under code is original in master version,please use it when you need.
- *	for (i = 0; i < iface->num_hw_features; i++) {
- *		mode = &iface->hw_features[i];
- *		if (!hostapd_hw_skip_mode(iface, mode))
- *			acs_find_ideal_chan_mode(iface, mode, n_chans, bw,
- *						 &rand_chan, &ideal_chan,
- *						 &ideal_factor);
- *	}
- */
-
-// the code in 18.06 version now is encapsulated in function acs_find_ideal_chan_mode()
-// add a parameter acs_chan_last_chan and call the function, you can change the number of parameter when you need.
-	mode = &iface->current_mode;
-	acs_find_ideal_chan_mode(iface, mode, n_chans, bw,
-				&rand_chan, &ideal_chan,
-				&ideal_factor, acs_chan_last_chan);
-//end
+// the under code is original in master version,please use it when you need.
+	for (i = 0; i < iface->num_hw_features; i++) {
+		mode = &iface->hw_features[i];
+		if (!hostapd_hw_skip_mode(iface, mode))
+			acs_find_ideal_chan_mode(iface, mode, n_chans, bw,
+						&rand_chan, &ideal_chan,
+						&ideal_factor);
+	}

 	if (ideal_chan) {
 		wpa_printf(MSG_DEBUG, "ACS: Ideal channel is %d (%d MHz) with total interference factor of %Lg",
Index: hostapd-2022-01-16-cff80b4f/wpa_supplicant/mesh.c
===================================================================
--- hostapd-2022-01-16-cff80b4f.orig/wpa_supplicant/mesh.c
+++ hostapd-2022-01-16-cff80b4f/wpa_supplicant/mesh.c
@@ -301,6 +301,8 @@ static int wpas_mesh_complete(struct wpa
 			ssid->id);
 		wpas_notify_mesh_group_started(wpa_s, ssid);
 	}
+
+	return ret;
 }


