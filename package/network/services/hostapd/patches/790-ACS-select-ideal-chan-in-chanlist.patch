--- a/src/ap/acs.c
+++ b/src/ap/acs.c
@@ -241,6 +241,56 @@
  * [1] http://en.wikipedia.org/wiki/Near_and_far_field
  */
 
+enum bw_type {
+	ACS_BW40,
+	ACS_BW80,
+	ACS_BW160,
+};
+
+struct bw_item {
+	int first;
+	int last;
+	int center_chan;
+};
+
+static const struct bw_item bw_40[] = {
+	{ 5180, 5200, 38 }, { 5220, 5240, 46 }, { 5260, 5280, 54 },
+	{ 5300, 5320, 62 }, { 5500, 5520, 102 }, { 5540, 5560, 110 },
+	{ 5580, 5600, 118 }, { 5620, 5640, 126 }, { 5660, 5680, 134 },
+	{ 5700, 5720, 142 }, { 5745, 5765, 151 }, { 5785, 5805, 159 },
+	{ 5825, 5845, 167 }, { 5865, 5885, 175 },
+	{ 5955, 5975, 3 }, { 5995, 6015, 11 }, { 6035, 6055, 19 },
+	{ 6075, 6095, 27 }, { 6115, 6135, 35 }, { 6155, 6175, 43 },
+	{ 6195, 6215, 51 }, { 6235, 6255, 59 }, { 6275, 6295, 67 },
+	{ 6315, 6335, 75 }, { 6355, 6375, 83 }, { 6395, 6415, 91 },
+	{ 6435, 6455, 99 }, { 6475, 6495, 107 }, { 6515, 6535, 115 },
+	{ 6555, 6575, 123 }, { 6595, 6615, 131 }, { 6635, 6655, 139 },
+	{ 6675, 6695, 147 }, { 6715, 6735, 155 }, { 6755, 6775, 163 },
+	{ 6795, 6815, 171 }, { 6835, 6855, 179 }, { 6875, 6895, 187 },
+	{ 6915, 6935, 195 }, { 6955, 6975, 203 }, { 6995, 7015, 211 },
+	{ 7035, 7055, 219 }, { 7075, 7095, 227}, { -1, -1, -1 }
+};
+static const struct bw_item bw_80[] = {
+	{ 5180, 5240, 42 }, { 5260, 5320, 58 }, { 5500, 5560, 106 },
+	{ 5580, 5640, 122 }, { 5660, 5720, 138 }, { 5745, 5805, 155 },
+	{ 5825, 5885, 171},
+	{ 5955, 6015, 7 }, { 6035, 6095, 23 }, { 6115, 6175, 39 },
+	{ 6195, 6255, 55 }, { 6275, 6335, 71 }, { 6355, 6415, 87 },
+	{ 6435, 6495, 103 }, { 6515, 6575, 119 }, { 6595, 6655, 135 },
+	{ 6675, 6735, 151 }, { 6755, 6815, 167 }, { 6835, 6895, 183 },
+	{ 6915, 6975, 199 }, { 6995, 7055, 215 }, { -1, -1, -1 }
+};
+static const struct bw_item bw_160[] = {
+	{ 5180, 5320, 50 }, { 5500, 5640, 114 }, { 5745, 5885, 163 },
+	{ 5955, 6095, 15 }, { 6115, 6255, 47 }, { 6275, 6415, 79 },
+	{ 6435, 6575, 111 }, { 6595, 6735, 143 },
+	{ 6755, 6895, 175 }, { 6915, 7055, 207 }, { -1, -1, -1 }
+};
+static const struct bw_item *bw_desc[] = {
+	[ACS_BW40] = bw_40,
+	[ACS_BW80] = bw_80,
+	[ACS_BW160] = bw_160,
+};
 
 static int acs_request_scan(struct hostapd_iface *iface);
 static int acs_survey_is_sufficient(struct freq_survey *survey);
@@ -373,15 +423,23 @@ acs_survey_chan_interference_factor(stru
 static int acs_usable_bw40_chan(const struct hostapd_channel_data *chan)
 {
 	const int allowed[] = { 5180, 5220, 5260, 5300, 5500, 5540, 5580, 5620,
-				5660, 5745, 5785, 4920, 4960, 5955, 5995, 6035,
-				6075, 6115, 6155, 6195, 6235, 6275, 6315, 6355,
-				6395, 6435, 6475, 6515, 6555, 6595, 6635, 6675,
-				6715, 6755, 6795, 6835, 6875, 6915, 6955, 6995,
-				7035, 7075 };
+				5660, 5700, 5745, 5785, 5825, 5865, 4920, 4960, 5955,
+				5995, 6035, 6075, 6115, 6155, 6195, 6235, 6275,
+				6315, 6355, 6395, 6435, 6475, 6515, 6555, 6595,
+				6635, 6675, 6715, 6755, 6795, 6835, 6875, 6915,
+				6955, 6995, 7035, 7075 };
+
+	const int last_allowed[] = {5200, 5240, 5280, 5320, 5520, 5560, 5600, 5640,
+				5680, 5720, 5765, 5805, 5845, 5885, 4940, 4980, 5975,
+				6015, 6055, 6095, 6135, 6175, 6215, 6255, 6295,
+				6335, 6375, 6415, 6455, 6495, 6535, 6575, 6615,
+				6655, 6695, 6735, 6775, 6815, 6855, 6895, 6935,
+				6975, 7015, 7055, 7095 };
 	unsigned int i;
 
 	for (i = 0; i < ARRAY_SIZE(allowed); i++)
-		if (chan->freq == allowed[i])
+		if (chan->freq >= allowed[i] &&
+		    chan->freq <= last_allowed[i])
 			return 1;
 
 	return 0;
@@ -390,13 +448,20 @@ static int acs_usable_bw40_chan(const st
 
 static int acs_usable_bw80_chan(const struct hostapd_channel_data *chan)
 {
-	const int allowed[] = { 5180, 5260, 5500, 5580, 5660, 5745, 5955, 6035,
+	const int allowed[] = { 5180, 5260, 5500, 5580, 5660, 5745, 5825, 5955, 6035,
 				6115, 6195, 6275, 6355, 6435, 6515, 6595, 6675,
 				6755, 6835, 6915, 6995 };
+
+	const int last_allowed[] = {5240, 5320, 5560, 5640, 5720, 5805, 5885, 6015, 6095,
+				6175, 6255, 6335, 6415, 6495, 6575, 6655, 6735,
+				6815, 6895, 6975, 7055};
+
+
 	unsigned int i;
 
 	for (i = 0; i < ARRAY_SIZE(allowed); i++)
-		if (chan->freq == allowed[i])
+		if (chan->freq >= allowed[i] &&
+		    chan->freq <= last_allowed[i])
 			return 1;
 
 	return 0;
@@ -405,17 +470,49 @@ static int acs_usable_bw80_chan(const st
 
 static int acs_usable_bw160_chan(const struct hostapd_channel_data *chan)
 {
-	const int allowed[] = { 5180, 5500, 5955, 6115, 6275, 6435, 6595, 6755,
+	const int allowed[] = { 5180, 5500, 5745, 5955, 6115, 6275, 6435, 6595, 6755,
 				6915 };
+
+	const int last_allowed[] = {5320, 5640, 5885, 6095, 6255, 6415, 6575, 6735, 6895,
+				7055};
+
 	unsigned int i;
 
 	for (i = 0; i < ARRAY_SIZE(allowed); i++)
-		if (chan->freq == allowed[i])
+		if (chan->freq >= allowed[i] &&
+		    chan->freq <= last_allowed[i])
 			return 1;
 
 	return 0;
 }
 
+static int acs_get_bw_center_chan(int freq, enum bw_type bw)
+{
+	unsigned int i = 0;
+
+	while (bw_desc[bw][i].first != -1) {
+		if (freq >= bw_desc[bw][i].first &&
+		    freq <= bw_desc[bw][i].last)
+			return bw_desc[bw][i].center_chan;
+		i++;
+	}
+
+	return 0;
+}
+
+static const struct bw_item *acs_get_bw_item(int freq, enum bw_type bw)
+{
+	unsigned int i = 0;
+
+	while (bw_desc[bw][i].first != -1) {
+		if (freq >= bw_desc[bw][i].first &&
+		    freq <= bw_desc[bw][i].last)
+			return &bw_desc[bw][i];
+		i++;
+	}
+
+	return NULL;
+}
 
 static int acs_survey_is_sufficient(struct freq_survey *survey)
 {
@@ -593,6 +690,26 @@ acs_find_chan_mode(struct hostapd_hw_mod
 }
 
 
+static enum hostapd_hw_mode
+acs_find_mode(struct hostapd_iface *iface, int freq)
+{
+	int i;
+	struct hostapd_hw_modes *mode;
+	struct hostapd_channel_data *chan;
+
+	for (i = 0; i < iface->num_hw_features; i++) {
+		mode = &iface->hw_features[i];
+		if (!hostapd_hw_skip_mode(iface, mode)) {
+			chan = acs_find_chan_mode(mode, freq);
+			if (chan)
+				return mode->mode;
+		}
+	}
+
+	return HOSTAPD_MODE_IEEE80211ANY;
+}
+
+
 static struct hostapd_channel_data *
 acs_find_chan(struct hostapd_iface *iface, int freq)
 {
@@ -666,6 +783,7 @@ acs_find_ideal_chan_mode(struct hostapd_
 	for (i = 0; i < mode->num_channels; i++) {
 		double total_weight;
 		struct acs_bias *bias, tmp_bias;
+		struct bw_item *bw_item = NULL;
 
 		chan = &mode->channels[i];
 
@@ -700,32 +818,39 @@ acs_find_ideal_chan_mode(struct hostapd_
 		if (mode->mode == HOSTAPD_MODE_IEEE80211A &&
 		    ((iface->conf->ieee80211n &&
 		      iface->conf->secondary_channel) ||
-		     is_6ghz_freq(chan->freq)) &&
-		    !acs_usable_bw40_chan(chan)) {
-			wpa_printf(MSG_DEBUG,
-				   "ACS: Channel %d: not allowed as primary channel for 40 MHz bandwidth",
-				   chan->chan);
-			continue;
+		     is_6ghz_freq(chan->freq))) {
+
+			bw_item = acs_get_bw_item(chan->freq, ACS_BW40);
+			if (!acs_usable_bw40_chan(chan)) {
+				wpa_printf(MSG_DEBUG,
+					"ACS: Channel %d: not allowed as primary channel for 40 MHz bandwidth",
+					chan->chan);
+				continue;
+			}
 		}
 
 		if (mode->mode == HOSTAPD_MODE_IEEE80211A &&
 		    (iface->conf->ieee80211ac || iface->conf->ieee80211ax)) {
 			if (hostapd_get_oper_chwidth(iface->conf) ==
-			    CHANWIDTH_80MHZ &&
-			    !acs_usable_bw80_chan(chan)) {
-				wpa_printf(MSG_DEBUG,
-					   "ACS: Channel %d: not allowed as primary channel for 80 MHz bandwidth",
-					   chan->chan);
-				continue;
+			    CHANWIDTH_80MHZ) {
+				bw_item = acs_get_bw_item(chan->freq, ACS_BW80);
+				if (!acs_usable_bw80_chan(chan)) {
+					wpa_printf(MSG_DEBUG,
+						"ACS: Channel %d: not allowed as primary channel for 80 MHz bandwidth",
+						chan->chan);
+					continue;
+				}
 			}
 
 			if (hostapd_get_oper_chwidth(iface->conf) ==
-			    CHANWIDTH_160MHZ &&
-			    !acs_usable_bw160_chan(chan)) {
-				wpa_printf(MSG_DEBUG,
-					   "ACS: Channel %d: not allowed as primary channel for 160 MHz bandwidth",
-					   chan->chan);
-				continue;
+			    CHANWIDTH_160MHZ) {
+				bw_item = acs_get_bw_item(chan->freq, ACS_BW160);
+				if (!acs_usable_bw160_chan(chan)) {
+					wpa_printf(MSG_DEBUG,
+						"ACS: Channel %d: not allowed as primary channel for 160 MHz bandwidth",
+						chan->chan);
+					continue;
+				}
 			}
 		}
 
@@ -735,7 +860,16 @@ acs_find_ideal_chan_mode(struct hostapd_
 		total_weight = 1;
 
 		for (j = 1; j < n_chans; j++) {
-			adj_chan = acs_find_chan(iface, chan->freq + (j * 20));
+			if (!is_24ghz_mode(mode->mode)) {
+				if (!bw_item) {
+					wpa_printf(MSG_DEBUG, "ACS: not found bw_item");
+					break;
+				}
+				adj_chan = acs_find_chan(iface, bw_item->first + (j * 20));
+			} else {
+				adj_chan = acs_find_chan(iface, chan->freq + (j * 20));
+			}
+
 			if (!adj_chan)
 				break;
 
@@ -928,21 +1062,49 @@ bw_selected:
 }
 
 
+static void acs_adjust_secondary(struct hostapd_iface *iface)
+{
+	unsigned int i;
+
+	/* When working with bandwidth over 20 MHz on the 5 GHz or 6 GHz band,
+	 * ACS can return a secondary channel which is not the first channel of
+	 * the segment and we need to adjust. */
+	if (!iface->conf->secondary_channel ||
+	    acs_find_mode(iface, iface->freq) != HOSTAPD_MODE_IEEE80211A)
+		return;
+
+	wpa_printf(MSG_DEBUG, "ACS: Adjusting HT/VHT/HE secondary frequency");
+
+	for (i = 0; bw_desc[ACS_BW40][i].first != -1; i++) {
+		if (iface->freq == bw_desc[ACS_BW40][i].first)
+			iface->conf->secondary_channel = 1;
+		else if (iface->freq == bw_desc[ACS_BW40][i].last)
+			iface->conf->secondary_channel = -1;
+	}
+}
+
+
 static void acs_adjust_center_freq(struct hostapd_iface *iface)
 {
-	int offset;
+	int center;
 
 	wpa_printf(MSG_DEBUG, "ACS: Adjusting VHT center frequency");
 
 	switch (hostapd_get_oper_chwidth(iface->conf)) {
 	case CHANWIDTH_USE_HT:
-		offset = 2 * iface->conf->secondary_channel;
+		if (iface->conf->secondary_channel &&
+		    iface->freq >= 2400 && iface->freq < 2500)
+			center = iface->conf->channel + 2 * iface->conf->secondary_channel;
+		else if (iface->conf->secondary_channel)
+			center = acs_get_bw_center_chan(iface->freq, ACS_BW40);
+		else
+		 	center = iface->conf->channel;
 		break;
 	case CHANWIDTH_80MHZ:
-		offset = 6;
+		center = acs_get_bw_center_chan(iface->freq, ACS_BW80);
 		break;
 	case CHANWIDTH_160MHZ:
-		offset = 14;
+		center = acs_get_bw_center_chan(iface->freq, ACS_BW160);
 		break;
 	default:
 		/* TODO: How can this be calculated? Adjust
@@ -951,9 +1113,7 @@ static void acs_adjust_center_freq(struc
 			   "ACS: Only VHT20/40/80/160 is supported now");
 		return;
 	}
-
-	hostapd_set_oper_centr_freq_seg0_idx(iface->conf,
-					     iface->conf->channel + offset);
+	hostapd_set_oper_centr_freq_seg0_idx(iface->conf, center);
 }
 
 
@@ -1009,8 +1169,10 @@ static void acs_study(struct hostapd_ifa
 	iface->conf->channel = ideal_chan->chan;
 	iface->freq = ideal_chan->freq;
 
-	if (iface->conf->ieee80211ac || iface->conf->ieee80211ax)
+	acs_adjust_secondary(iface);
+	if (iface->conf->ieee80211ac || iface->conf->ieee80211ax) {
 		acs_adjust_center_freq(iface);
+	}
 
 	err = 0;
 fail:
