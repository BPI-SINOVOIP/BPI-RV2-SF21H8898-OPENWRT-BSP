Index: netifd-2022-02-20-136006b8/interface.h
===================================================================
--- netifd-2022-02-20-136006b8.orig/interface.h
+++ netifd-2022-02-20-136006b8/interface.h
@@ -37,6 +37,7 @@ enum interface_state {
 	IFS_UP,
 	IFS_TEARDOWN,
 	IFS_DOWN,
+	IFS_REP,
 };
 
 enum interface_config_state {
Index: netifd-2022-02-20-136006b8/scripts/netifd-wireless.sh
===================================================================
--- netifd-2022-02-20-136006b8.orig/scripts/netifd-wireless.sh
+++ netifd-2022-02-20-136006b8/scripts/netifd-wireless.sh
@@ -8,6 +8,10 @@ CMD_SET_DATA=1
 CMD_PROCESS_ADD=2
 CMD_PROCESS_KILL_ALL=3
 CMD_SET_RETRY=4
+CMD_WPAUP=5
+CMD_PROCESS_ADDWPA=6
+CMD_PROCESS_KILL_WPA=7
+CMD_SET_WPARETRY=8
 
 add_driver() {
 	return
@@ -192,6 +196,35 @@ _wireless_set_retry() {
 	_wdev_notify
 }
 
+_wireless_set_up_wpas() {
+	_wdev_notify_init $CMD_WPAUP
+	_wdev_notify
+}
+
+_wireless_add_process_wpas() {
+	_wdev_notify_init $CMD_PROCESS_ADDWPA
+	local exe="$2"
+       [ -L "$exe"  ] && exe="$(readlink -f "$exe")"
+       json_add_int pid "$1"
+       json_add_string exe "$exe"
+       [ -n "$3"  ] && json_add_boolean required 1
+       exe2="$(readlink -f /proc/$1/exe)"
+       [ "$exe" != "$exe2"  ] && echo "WARNING (wireless_add_process): executable path $exe does not match process $1 path ($exe2)"
+       _wdev_notify
+}
+
+_wireless_process_kill_wpas() {
+       _wdev_notify_init $CMD_PROCESS_KILL_WPA
+       [ -n "$1"  ] && json_add_int signal "$1"
+       _wdev_notify
+}
+  
+_wireless_set_retry_wpas() {
+       _wdev_notify_init $CMD_SET_WPARETRY
+       json_add_int retry "$1"
+       _wdev_notify
+}
+
 _wdev_wrapper \
 	wireless_add_vif \
 	wireless_add_vlan \
@@ -200,6 +233,10 @@ _wdev_wrapper \
 	wireless_add_process \
 	wireless_process_kill_all \
 	wireless_set_retry \
+	wireless_set_up_wpas \
+        wireless_add_process_wpas \
+        wireless_process_kill_wpas \
+        wireless_set_retry_wpas
 
 wireless_vif_parse_encryption() {
 	json_get_vars encryption
@@ -413,7 +450,7 @@ init_wireless_driver() {
 				json_dump
 			}
 		;;
-		setup|teardown)
+		setup|teardown|repup|repdown)
 			interface="$1"; shift
 			data="$1"; shift
 			export __netifd_device="$interface"
Index: netifd-2022-02-20-136006b8/wireless.c
===================================================================
--- netifd-2022-02-20-136006b8.orig/wireless.c
+++ netifd-2022-02-20-136006b8/wireless.c
@@ -250,14 +250,27 @@ wireless_complete_kill_request(struct wi
 }
 
 static void
-wireless_process_free(struct wireless_device *wdev, struct wireless_process *proc)
+wireless_complete_wpas_kill_request(struct wireless_device *wdev)
+{
+       if (!wdev->wpa_kill_request)
+             return;
+ 
+       ubus_complete_deferred_request(ubus_ctx, wdev->wpa_kill_request, 0);
+       free(wdev->wpa_kill_request);
+       wdev->wpa_kill_request = NULL;
+}
+
+static void
+wireless_process_free(struct wireless_device *wdev, struct wireless_process *proc, bool mode)
 {
 	D(WIRELESS, "Wireless device '%s' free pid %d\n", wdev->name, proc->pid);
 	list_del(&proc->list);
 	free(proc);
 
-	if (list_empty(&wdev->script_proc))
+	if (mode && list_empty(&wdev->script_proc))
 		wireless_complete_kill_request(wdev);
+	if (!mode && list_empty(&wdev->wpa_script_proc))
+		wireless_complete_wpas_kill_request(wdev);
 }
 
 static void
@@ -272,6 +285,17 @@ wireless_close_script_proc_fd(struct wir
 }
 
 static void
+wireless_close_wpas_script_proc_fd(struct wireless_device *wdev)
+{
+       if (wdev->wpa_script_proc_fd.fd < 0)
+             return;
+       uloop_fd_delete(&wdev->wpa_script_proc_fd);
+       close(wdev->wpa_script_proc_fd.fd);
+       wdev->wpa_script_proc_fd.fd = -1;
+ 
+}
+
+static void
 wireless_process_kill_all(struct wireless_device *wdev, int signal, bool free)
 {
 	struct wireless_process *proc, *tmp;
@@ -285,7 +309,7 @@ wireless_process_kill_all(struct wireles
 		}
 
 		if (free || !check)
-			wireless_process_free(wdev, proc);
+			wireless_process_free(wdev, proc,true);
 	}
 
 	if (free)
@@ -293,32 +317,78 @@ wireless_process_kill_all(struct wireles
 }
 
 static void
+wireless_process_kill_wpas(struct wireless_device *wdev, int signal, bool free)
+{
+       struct wireless_process *proc, *tmp;
+
+       list_for_each_entry_safe(proc, tmp, &wdev->wpa_script_proc, list) {
+               bool check = wireless_process_check(proc);
+
+               if (check) {
+                       D(WIRELESS, "Wireless device wpa '%s' kill pid %d\n", wdev->name, proc->pid);
+                       kill(proc->pid, signal);
+                       }
+               if (free || !check)
+    	                 wireless_process_free(wdev, proc, false);
+       }
+ 
+       if (free)
+             wireless_close_wpas_script_proc_fd(wdev);
+}
+
+//@wireless_device_mark_free free wdev->data when ap and wpas down
+static void
+wireless_device_mark_free(struct wireless_device *wdev)
+{
+       if (wdev->state == IFS_DOWN && wdev->wpa_state == IFS_DOWN)
+       {
+               free(wdev->data);
+               wdev->data = NULL;
+       }
+
+}
+
+static void
 wireless_device_free_state(struct wireless_device *wdev)
 {
 	struct wireless_interface *vif;
-	struct wireless_vlan *vlan;
-	struct wireless_station *sta;
+	//struct wireless_vlan *vlan;
+	//struct wireless_station *sta;
 
 	wireless_handler_stop(wdev);
 	uloop_timeout_cancel(&wdev->script_check);
 	uloop_timeout_cancel(&wdev->timeout);
 	wireless_complete_kill_request(wdev);
-	free(wdev->data);
-	wdev->data = NULL;
+	wireless_device_mark_free(wdev);
+        vlist_for_each_element(&wdev->interfaces, vif, node) {
+               if (vif->ap_mode)
+               {
+                       free(vif->data);
+                       vif->data = NULL;
+                       vif->ifname = NULL;
+               }
+       }	
+}
+
+static void
+wireless_device_free_wpas_state(struct wireless_device *wdev)
+{
+        struct wireless_interface *vif;
+
+        uloop_timeout_cancel(&wdev->wpa_script_check);
+
+        uloop_timeout_cancel(&wdev->wpa_timeout);
+        wireless_complete_wpas_kill_request(wdev);
+        wireless_device_mark_free(wdev);
+
 	vlist_for_each_element(&wdev->interfaces, vif, node) {
-		free(vif->data);
-		vif->data = NULL;
-		vif->ifname = NULL;
-	}
-	vlist_for_each_element(&wdev->vlans, vlan, node) {
-		free(vlan->data);
-		vlan->data = NULL;
-		vlan->ifname = NULL;
-	}
-	vlist_for_each_element(&wdev->stations, sta, node) {
-		free(sta->data);
-		sta->data = NULL;
-	}
+		if (!vif->ap_mode)
+                {
+                       free(vif->data);
+                       vif->data = NULL;
+                       vif->ifname = NULL;
+                }
+         }
 }
 
 static void wireless_interface_handle_link(struct wireless_interface *vif, const char *ifname, bool up)
@@ -400,6 +470,18 @@ wireless_device_setup_cancel(struct wire
 	if (wdev->cancel)
 		return;
 
+	D(WIRELESS, "Cancel wireless device '%s' setup\n", wdev->name);
+	wdev->cancel = true;
+	uloop_timeout_set(&wdev->timeout, 15 * 1000);
+}
+
+
+static void
+wireless_device_setup_wpas_cancel(struct wireless_device *wdev)
+{
+	if (wdev->cancel)
+		return;
+
 	wireless_handler_stop(wdev);
 	D(WIRELESS, "Cancel wireless device '%s' setup\n", wdev->name);
 	wdev->cancel = true;
@@ -407,13 +489,37 @@ wireless_device_setup_cancel(struct wire
 }
 
 static void
-wireless_device_run_handler(struct wireless_device *wdev, bool up)
+wireless_device_run_handler(struct wireless_device *wdev, bool ap,enum wireless_config s)
 {
-	const char *action = up ? "setup" : "teardown";
 	const char *argv[6];
-	char *config;
+	const char *action;
+	bool up;
 	int i = 0;
 	int fds[2] = { -1, -1 };
+	char *config;
+ 
+        switch (s) {
+        	case WDEV_TEARDOWN:
+                        action = "teardown";
+                       up = false;
+                       break;
+                case WDEV_SETUP:
+                       action = "setup";
+                       up = true;
+                       break;
+               case WDEV_REPUP:
+                       action = "repup";
+                       up = true;
+                       break;
+               case WDEV_REPDOWN:
+                       action = "repdown";
+                       up = false;
+                       break;
+               default:
+               action = "setup";
+               up = true;
+                       break;
+       }	
 
 	wireless_handler_stop(wdev);
 
@@ -443,16 +549,21 @@ wireless_device_run_handler(struct wirel
 	argv[i++] = config;
 	argv[i] = NULL;
 
-	if (up && pipe(fds) == 0) {
-		if (wdev->script_proc_fd.fd >= 0)
-			wireless_close_script_proc_fd(wdev);
-
-		wdev->script_proc_fd.fd = fds[0];
-		uloop_fd_add(&wdev->script_proc_fd,
-			     ULOOP_READ | ULOOP_EDGE_TRIGGER);
-	}
-
-	netifd_start_process(argv, NULL, &wdev->script_task);
+	if (ap) {
+               if (up && pipe(fds) == 0) {
+                       wdev->script_proc_fd.fd = fds[0];
+                       uloop_fd_add(&wdev->script_proc_fd,
+                                               ULOOP_READ | ULOOP_EDGE_TRIGGER);
+               }
+               netifd_start_process(argv, NULL, &wdev->script_task);
+       } else {
+               if (up && pipe(fds) == 0) {
+                       wdev->wpa_script_proc_fd.fd = fds[0];
+                       uloop_fd_add(&wdev->wpa_script_proc_fd,
+                                               ULOOP_READ | ULOOP_EDGE_TRIGGER);
+               }
+               netifd_start_process(argv, NULL, &wdev->wpa_script_task);
+        }
 
 	if (fds[1] >= 0)
 		close(fds[1]);
@@ -472,11 +583,11 @@ wireless_handler_next(void)
 	wdev = list_first_entry(&handlers, struct wireless_device, handler);
 	list_del(&wdev->handler);
 	wdev->handler_pending = false;
-	wireless_device_run_handler(wdev, wdev->handler_action);
+	wireless_device_run_handler(wdev,true, wdev->handler_action);
 }
 
 static void
-__wireless_device_set_up(struct wireless_device *wdev, int force)
+__wireless_device_set_up(struct wireless_device *wdev)
 {
 	if (wdev->disabled)
 		return;
@@ -487,13 +598,49 @@ __wireless_device_set_up(struct wireless
 	if (!wdev->autostart)
 		return;
 
-	if (!force && (wdev->state != IFS_DOWN || config_init))
+	if  (wdev->state != IFS_DOWN || config_init)
 		return;
 
 	free(wdev->prev_config);
 	wdev->prev_config = NULL;
 	wdev->state = IFS_SETUP;
-	wireless_device_run_handler(wdev, true);
+	wireless_device_run_handler(wdev, true, WDEV_SETUP);
+}
+
+static void
+__wireless_wpas_set_up(struct wireless_device *wdev)
+{
+       if (wdev->disabled)
+             return;
+
+       if (wdev->retry_setup_failed)
+               return;
+
+       if (!wdev->autostart)
+               return;
+
+       if (wdev->wpa_state != IFS_DOWN || config_init)
+             return;
+
+       free(wdev->prev_config);
+       wdev->prev_config = NULL;
+       wdev->wpa_state = IFS_SETUP;
+       wireless_device_run_handler(wdev, false, WDEV_REPUP);
+
+}
+
+static void
+wireless_hostap_set_up(struct wireless_device *wdev)
+{
+       wdev->retry = WIRELESS_SETUP_RETRY;
+       wdev->autostart = true;
+}
+
+static void
+wireless_wpas_set_up(struct wireless_device *wdev)
+{
+       wdev->wpa_retry = WIRELESS_SETUP_RETRY;
+       wdev->wpa_autostart = true;
 }
 
 static void
@@ -518,23 +665,49 @@ wdev_handle_config_change(struct wireles
 	case IFC_NORMAL:
         case IFC_RELOAD:
                 if (wdev->autostart){
-                        __wireless_device_set_up(wdev,0);
+                        __wireless_device_set_up(wdev);
                 } else {
                         //force set up if autostart retry max reached by something has changed
-                        if(is_config_changed)
-                              wireless_device_set_up(wdev);
+                        if(is_config_changed) wireless_hostap_set_up(wdev);
                 }
 
 		wdev->config_state = IFC_NORMAL;
 		break;
 	case IFC_REMOVE:
-		wireless_device_free(wdev);
+		wdev->hostap_remove = true;
+		if (wdev->wpas_remove)
+			if (wdev->wpas_remove)
 		break;
 	}
 }
 
 static void
-wireless_device_mark_down(struct wireless_device *wdev)
+wdev_handle_wpasconfig_change(struct wireless_device *wdev, bool is_config_changed)
+{
+       enum interface_config_state state = wdev->wpa_config_state;
+
+       switch(state) {
+       case IFC_NORMAL:
+       case IFC_RELOAD:
+               if (wdev->wpa_autostart){
+                       __wireless_wpas_set_up(wdev);
+               }else{
+                       //force set up if autostart retry max reached by something has changed
+                       if(is_config_changed) wireless_wpas_set_up(wdev);
+               }
+
+               wdev->wpa_config_state = IFC_NORMAL;
+               break;
+      case IFC_REMOVE:
+             	wdev->wpas_remove = true;
+               if (wdev->hostap_remove)
+                       wireless_device_free(wdev);
+                break;
+      }
+}
+
+static void
+wireless_device_mark_down(struct wireless_device *wdev, bool mode)
 {
 	struct wireless_interface *vif;
 	struct wireless_vlan *vlan;
@@ -545,14 +718,23 @@ wireless_device_mark_down(struct wireles
 		wireless_vlan_handle_link(vlan, false);
 
 	vlist_for_each_element(&wdev->interfaces, vif, node)
-		wireless_interface_handle_link(vif, NULL, false);
-
-	wireless_process_kill_all(wdev, SIGTERM, true);
-
-	wdev->cancel = false;
-	wdev->state = IFS_DOWN;
-	wireless_device_free_state(wdev);
-	wdev_handle_config_change(wdev,false);
+	{
+		if (vif->ap_mode == mode)
+			wireless_interface_handle_link(vif, NULL, false);
+	}
+	if (mode) {
+		wireless_process_kill_all(wdev, SIGTERM, true);
+		wdev->cancel = false;
+		wdev->state = IFS_DOWN;
+		wireless_device_free_state(wdev);
+		wdev_handle_config_change(wdev, false);
+	} else {
+		wireless_process_kill_wpas(wdev, SIGTERM, true);
+		wdev->wpa_cancel = false;
+		wdev->wpa_state = IFS_DOWN;
+		wireless_device_free_wpas_state(wdev);
+		wdev_handle_wpasconfig_change(wdev, false);
+	}
 }
 
 /* timeout callback to protect the tear down */
@@ -567,15 +749,27 @@ wireless_device_setup_timeout(struct ulo
 	}
 	netifd_kill_process(&wdev->script_task);
 	wdev->script_task.cb(&wdev->script_task, -1);
-	wireless_device_mark_down(wdev);
+	wireless_device_mark_down(wdev, true);
+}
+
+static void
+wireless_wpas_setup_timeout(struct uloop_timeout *wpa_timeout)
+{
+       struct wireless_device *wdev = container_of(wpa_timeout, struct wireless_device, wpa_timeout);
+
+       netifd_kill_process(&wdev->wpa_script_task);
+       wdev->wpa_script_task.cb(&wdev->wpa_script_task, -1);
+       wireless_device_mark_down(wdev, false);
 }
 
 void
 wireless_device_set_up(struct wireless_device *wdev)
 {
-	wdev->retry = WIRELESS_SETUP_RETRY;
-	wdev->autostart = true;
-	__wireless_device_set_up(wdev, 0);
+	wireless_hostap_set_up(wdev);
+	wireless_wpas_set_up(wdev);
+	
+	__wireless_device_set_up(wdev);
+	__wireless_wpas_set_up(wdev);
 }
 
 void
@@ -583,11 +777,11 @@ wireless_device_reconf(struct wireless_d
 {
 	wdev->retry = WIRELESS_SETUP_RETRY;
 	wdev->autostart = true;
-	__wireless_device_set_up(wdev, wdev->reconf && (wdev->state == IFS_UP));
+	__wireless_device_set_up(wdev);
 }
 
 static void
-__wireless_device_set_down(struct wireless_device *wdev)
+__wireless_hostap_set_down(struct wireless_device *wdev)
 {
 	if (wdev->state == IFS_TEARDOWN || wdev->state == IFS_DOWN)
 		return;
@@ -598,7 +792,22 @@ __wireless_device_set_down(struct wirele
 	}
 
 	wdev->state = IFS_TEARDOWN;
-	wireless_device_run_handler(wdev, false);
+	wireless_device_run_handler(wdev, true, WDEV_TEARDOWN);
+}
+
+static void
+__wireless_wpas_set_down(struct wireless_device *wdev)
+{
+       if (wdev->wpa_state == IFS_TEARDOWN || wdev->wpa_state == IFS_DOWN)
+             return;
+
+      if (wdev->wpa_script_task.uloop.pending) {
+               wireless_device_setup_wpas_cancel(wdev);
+               return;
+       }
+
+       wdev->wpa_state = IFS_TEARDOWN;
+       wireless_device_run_handler(wdev, false, WDEV_REPDOWN);
 }
 
 /* ubus callback network.wireless.notify, command = up */
@@ -606,11 +815,11 @@ static void
 wireless_device_mark_up(struct wireless_device *wdev)
 {
 	struct wireless_interface *vif;
-	struct wireless_vlan *vlan;
+	//struct wireless_vlan *vlan;
 
 	if (wdev->cancel) {
 		wdev->cancel = false;
-		__wireless_device_set_down(wdev);
+		__wireless_hostap_set_down(wdev);
 		return;
 	}
 
@@ -618,31 +827,58 @@ wireless_device_mark_up(struct wireless_
 	wdev->retry = WIRELESS_SETUP_RETRY;
 	wdev->state = IFS_UP;
 	vlist_for_each_element(&wdev->interfaces, vif, node)
-		wireless_interface_handle_link(vif, NULL, true);
-	vlist_for_each_element(&wdev->vlans, vlan, node)
-		wireless_vlan_handle_link(vlan, true);
+	{
+		if (vif->ap_mode)
+			wireless_interface_handle_link(vif,NULL, true);
+	}
 }
 
 static void
-wireless_device_retry_setup(struct wireless_device *wdev)
+wireless_wpas_mark_up(struct wireless_device *wdev)
 {
-	if (wdev->state == IFS_TEARDOWN || wdev->state == IFS_DOWN || wdev->cancel)
-		return;
+       struct wireless_interface *vif;
 
-	__wireless_device_set_down(wdev);
+        if (wdev->wpa_cancel) {
+               wdev->wpa_cancel = false;
+               __wireless_wpas_set_down(wdev);
+                 return;
+       }
+ 
+       D(WIRELESS, "Wireless device '%s' is now up\n", wdev->name);
+       wdev->wpa_state = IFS_UP;
+       vlist_for_each_element(&wdev->interfaces, vif, node)
+       {
+               if (!vif->ap_mode)
+                     wireless_interface_handle_link(vif,NULL, true);
+       }
+}
+
+static void
+wireless_device_retry_setup(struct wireless_device *wdev, bool mode)
+{
+       if (mode && (wdev->state == IFS_TEARDOWN || wdev->state == IFS_DOWN || wdev->cancel))
+               return;
+ 
+       if (!mode && (wdev->wpa_state == IFS_TEARDOWN || wdev->wpa_state == IFS_DOWN || wdev->wpa_cancel))
+             return;
+       if (mode)
+               __wireless_hostap_set_down(wdev);
+       else
+             __wireless_wpas_set_down(wdev);
 }
 
 static void
 wireless_device_script_task_cb(struct netifd_process *proc, int ret)
 {
 	struct wireless_device *wdev = container_of(proc, struct wireless_device, script_task);
+	bool mode = true;	
 
 	switch (wdev->state) {
 	case IFS_SETUP:
-		wireless_device_retry_setup(wdev);
+		wireless_device_retry_setup(wdev, mode);
 		break;
 	case IFS_TEARDOWN:
-		wireless_device_mark_down(wdev);
+		wireless_device_mark_down(wdev, mode);
 		break;
 	default:
 		break;
@@ -654,15 +890,50 @@ wireless_device_script_task_cb(struct ne
 	}
 }
 
+static void
+wireless_wpas_script_task_cb(struct netifd_process *proc, int ret)
+{
+       struct wireless_device *wdev = container_of(proc, struct wireless_device, wpa_script_task);
+       bool mode = false;
+
+       switch (wdev->wpa_state) {
+       case IFS_SETUP:
+               wireless_device_retry_setup(wdev, mode);
+               break;
+       case IFS_TEARDOWN:
+               wireless_device_mark_down(wdev, mode);
+               break;
+       default:
+               break;
+       }
+}
+
 void
 wireless_device_set_down(struct wireless_device *wdev)
 {
 	wdev->retry_setup_failed = false;
 	wdev->autostart = false;
-	__wireless_device_set_down(wdev);
+	wdev->wpa_autostart =false;
+	__wireless_hostap_set_down(wdev);
+	__wireless_wpas_set_down(wdev);
 }
 
 static void
+wdev_set_wpas_config_state(struct wireless_device *wdev, enum interface_config_state s)
+{
+       if (wdev->wpa_config_state != IFC_NORMAL)
+             return;
+
+       wdev->wpa_config_state = s;
+       if (wdev->wpa_state == IFS_DOWN)
+               wdev_handle_wpasconfig_change(wdev, true);
+       else {
+               __wireless_wpas_set_down(wdev);
+       }
+}
+
+
+static void
 wdev_set_config_state(struct wireless_device *wdev, enum interface_config_state s)
 {
 	if (wdev->config_state != IFC_NORMAL)
@@ -672,7 +943,7 @@ wdev_set_config_state(struct wireless_de
 	if (wdev->state == IFS_DOWN)
 		wdev_handle_config_change(wdev,true);
 	else if (!wdev->reconf || wdev->state != IFS_UP)
-		__wireless_device_set_down(wdev);
+		__wireless_hostap_set_down(wdev);
 }
 
 static void
@@ -690,10 +961,13 @@ wdev_change_config(struct wireless_devic
 {
 	struct blob_attr *new_config = wd_new->config;
 	bool disabled = wd_new->disabled;
-
+	
+	bool able = false;
 	free(wd_new);
 
 	wdev_prepare_prev_config(wdev);
+	if (wdev->disabled != disabled)
+		able = true;
 	if (blob_attr_equal(wdev->config, new_config) && wdev->disabled == disabled)
 		return;
 
@@ -702,12 +976,18 @@ wdev_change_config(struct wireless_devic
 	wdev->config = blob_memdup(new_config);
 	wdev->disabled = disabled;
 	wdev_set_config_state(wdev, IFC_RELOAD);
+	wdev->retry_setup_failed = false;
+	if (able)
+		wdev_set_wpas_config_state(wdev, IFC_RELOAD);
 }
 
 static void
 wdev_create(struct wireless_device *wdev)
 {
 	wdev->retry = WIRELESS_SETUP_RETRY;
+	wdev->hostap_remove = false;
+	wdev->wpa_retry = WIRELESS_SETUP_RETRY;
+	wdev->wpas_remove = false;
 	wdev->config = blob_memdup(wdev->config);
 }
 
@@ -725,6 +1005,7 @@ wdev_update(struct vlist_tree *tree, str
 	} else if (wd_old) {
 		D(WIRELESS, "Delete wireless device '%s'\n", wd_old->name);
 		wdev_set_config_state(wd_old, IFC_REMOVE);
+		wdev_set_wpas_config_state(wd_old, IFC_REMOVE);
 	} else if (wd_new) {
 		D(WIRELESS, "Create wireless device '%s'\n", wd_new->name);
 		wdev_create(wd_new);
@@ -842,10 +1123,12 @@ vif_update(struct vlist_tree *tree, stru
 	struct wireless_interface *vif_old = container_of(node_old, struct wireless_interface, node);
 	struct wireless_interface *vif_new = container_of(node_new, struct wireless_interface, node);
 	struct wireless_device *wdev;
+	bool mode_old;
 
-	if (vif_old)
+	if (vif_old){
 		wdev = vif_old->wdev;
-	else
+		mode_old = vif_old->ap_mode;
+	}else
 		wdev = vif_new->wdev;
 
 	if (vif_old && vif_new) {
@@ -867,6 +1150,7 @@ vif_update(struct vlist_tree *tree, stru
 		vif_new->section = strdup(vif_new->section);
 		vif_new->config = blob_memdup(vif_new->config);
 		wireless_interface_init_config(vif_new);
+		mode_old = vif_new->ap_mode;
 	} else if (vif_old) {
 		D(WIRELESS, "Delete wireless interface %s on device %s\n", vif_old->name, wdev->name);
 		wireless_interface_handle_link(vif_old, NULL, false);
@@ -875,7 +1159,10 @@ vif_update(struct vlist_tree *tree, stru
 		free(vif_old);
 	}
 
-	wdev_set_config_state(wdev, IFC_RELOAD);
+	if (mode_old)
+		wdev_set_config_state(wdev, IFC_RELOAD);
+	else
+		wdev_set_wpas_config_state(wdev, IFC_RELOAD);
 }
 
 /* parse blob config into the vlan object */
@@ -982,9 +1269,8 @@ station_update(struct vlist_tree *tree,
 }
 
 static void
-wireless_proc_poll_fd(struct uloop_fd *fd, unsigned int events)
+wireless_proc_poll_fd_t(struct uloop_fd *fd, unsigned int events,struct wireless_device *wdev, bool mode)
 {
-	struct wireless_device *wdev = container_of(fd, struct wireless_device, script_proc_fd);
 	char buf[128];
 
 	while (1) {
@@ -1004,8 +1290,27 @@ wireless_proc_poll_fd(struct uloop_fd *f
 	}
 
 done:
-	uloop_timeout_set(&wdev->script_check, 0);
-	wireless_close_script_proc_fd(wdev);
+	if (mode) {
+		uloop_timeout_set(&wdev->script_check, 0);
+		wireless_close_script_proc_fd(wdev);
+	} else {
+		uloop_timeout_set(&wdev->wpa_script_check, 0);
+		wireless_close_wpas_script_proc_fd(wdev);
+	}
+}
+
+static void
+wireless_proc_poll_fd(struct uloop_fd *fd, unsigned int events)
+{
+       struct wireless_device *wdev = container_of(fd, struct wireless_device, script_proc_fd);
+       wireless_proc_poll_fd_t(fd, events, wdev, true);
+}
+
+static void
+wireless_proc_wpas_poll_fd(struct uloop_fd *fd, unsigned int events)
+{
+       struct wireless_device *wdev = container_of(fd, struct wireless_device, wpa_script_proc_fd);
+       wireless_proc_poll_fd_t(fd, events, wdev, false);
 }
 
 /* watchdog and garbage collector for wireless processes.
@@ -1025,15 +1330,39 @@ wireless_device_check_script_tasks(struc
 		if (proc->required)
 			restart = true;
 
-		wireless_process_free(wdev, proc);
+		wireless_process_free(wdev, proc, true);
 	}
 
 	if (restart)
-		wireless_device_retry_setup(wdev);
+		wireless_device_retry_setup(wdev, true);
 	else
 		uloop_timeout_set(&wdev->script_check, 1000);
 }
 
+static void
+wireless_device_check_wpas_script_tasks(struct uloop_timeout *timeout)
+{
+       struct wireless_device *wdev = container_of(timeout, struct wireless_device, wpa_script_check);
+       struct wireless_process *proc, *tmp;
+       bool restart = false;
+
+       list_for_each_entry_safe(proc, tmp, &wdev->wpa_script_proc, list) {
+               if (wireless_process_check(proc))
+                     continue;
+
+               D(WIRELESS, "Wireless device '%s' pid %d has terminated\n", wdev->name, proc->pid);
+               if (proc->required)
+                     restart = true;
+
+               wireless_process_free(wdev, proc, false);
+       }
+
+       if (restart)
+             wireless_device_retry_setup(wdev, false);
+       else
+             uloop_timeout_set(&wdev->wpa_script_check, 1000);
+}
+
 /* creates a wireless device object. Called by config */
 void
 wireless_device_create(struct wireless_driver *drv, const char *name, struct blob_attr *data)
@@ -1053,6 +1382,8 @@ wireless_device_create(struct wireless_d
 	wdev->drv = drv;
 	wdev->state = IFS_DOWN;
 	wdev->config_state = IFC_NORMAL;
+	wdev->wpa_state = IFS_DOWN;
+	wdev->wpa_config_state = IFC_NORMAL;
 	wdev->name = strcpy(name_buf, name);
 	wdev->config = data;
 	wdev->handler_pending = false;
@@ -1065,7 +1396,11 @@ wireless_device_create(struct wireless_d
 
 	wdev->retry_setup_failed = false;
 	wdev->autostart = true;
+	wdev->wpa_autostart = true;
+
 	INIT_LIST_HEAD(&wdev->script_proc);
+	INIT_LIST_HEAD(&wdev->wpa_script_proc);
+
 	vlist_init(&wdev->interfaces, avl_strcmp, vif_update);
 	wdev->interfaces.keep_old = true;
 	vlist_init(&wdev->vlans, avl_strcmp, vlan_update);
@@ -1078,9 +1413,18 @@ wireless_device_create(struct wireless_d
 	wdev->script_task.dir_fd = drv_fd;
 	wdev->script_task.log_prefix = wdev->name;
 
+	wdev->wpa_timeout.cb = wireless_wpas_setup_timeout;
+	wdev->wpa_script_task.cb = wireless_wpas_script_task_cb;
+	wdev->wpa_script_task.dir_fd = drv_fd;
+	wdev->wpa_script_task.log_prefix = wdev->name;
+
+	wdev->wpa_script_proc_fd.fd = -1;
+	wdev->wpa_script_proc_fd.cb = wireless_proc_wpas_poll_fd;
+
 	wdev->script_proc_fd.fd = -1;
 	wdev->script_proc_fd.cb = wireless_proc_poll_fd;
-
+	
+	wdev->wpa_script_check.cb = wireless_device_check_wpas_script_tasks;
 	wdev->script_check.cb = wireless_device_check_script_tasks;
 
 	vlist_add(&wireless_devices, &wdev->node, wdev->name);
@@ -1245,6 +1589,7 @@ wireless_device_status(struct wireless_d
 	blobmsg_add_u8(b, "autostart", wdev->autostart);
 	blobmsg_add_u8(b, "disabled", wdev->disabled);
 	blobmsg_add_u8(b, "retry_setup_failed", wdev->retry_setup_failed);
+	blobmsg_add_u32(b, "config_state", wdev->config_state);
 	put_container(b, wdev->config, "config");
 
 	i = blobmsg_open_array(b, "interfaces");
@@ -1323,7 +1668,7 @@ wireless_vlan_set_data(struct wireless_v
 
 /* ubus callback network.wireless.notify, command = process add */
 static int
-wireless_device_add_process(struct wireless_device *wdev, struct blob_attr *data)
+wireless_device_add_process(struct wireless_device *wdev, struct blob_attr *data, bool ap)
 {
 	enum {
 		PROC_ATTR_PID,
@@ -1367,16 +1712,20 @@ wireless_device_add_process(struct wirel
 		proc->keep = blobmsg_get_bool(tb[PROC_ATTR_KEEP]);
 
 	D(WIRELESS, "Wireless device '%s' add pid %d\n", wdev->name, proc->pid);
-	list_add(&proc->list, &wdev->script_proc);
-	uloop_timeout_set(&wdev->script_check, 0);
+	if (ap){
+		list_add(&proc->list, &wdev->script_proc);
+		uloop_timeout_set(&wdev->script_check, 0);
+	}else{
+		list_add(&proc->list, &wdev->wpa_script_proc);
+		uloop_timeout_set(&wdev->wpa_script_check, 0);
+	}
 
 	return 0;
 }
 
 /* ubus callback network.wireless.notify, command = process kill all */
 static int
-wireless_device_process_kill_all(struct wireless_device *wdev, struct blob_attr *data,
-				 struct ubus_request_data *req)
+wireless_device_process_kill_all(struct wireless_device *wdev, struct blob_attr *data,struct ubus_request_data *req, bool ap)
 {
 	enum {
 		KILL_ATTR_SIGNAL,
@@ -1400,23 +1749,28 @@ wireless_device_process_kill_all(struct
 	if ((cur = tb[KILL_ATTR_IMMEDIATE]))
 		immediate = blobmsg_get_bool(cur);
 
-	if (wdev->state != IFS_TEARDOWN || wdev->kill_request)
+	if ((wdev->state != IFS_TEARDOWN || wdev->kill_request) &&(wdev->wpa_state != IFS_TEARDOWN || wdev->wpa_kill_request))
 		return UBUS_STATUS_PERMISSION_DENIED;
-
-	wireless_process_kill_all(wdev, signal, immediate);
-
-	if (list_empty(&wdev->script_proc))
-		return 0;
-
-	wdev->kill_request = calloc(1, sizeof(*wdev->kill_request));
-	ubus_defer_request(ubus_ctx, req, wdev->kill_request);
-
+	if (ap)
+	{
+		wireless_process_kill_all(wdev, signal, immediate);
+		if (list_empty(&wdev->script_proc))
+			return 0;
+		wdev->kill_request = calloc(1, sizeof(*wdev->kill_request));
+		ubus_defer_request(ubus_ctx, req, wdev->kill_request);
+	} else {
+		wireless_process_kill_wpas(wdev, signal, immediate);
+		if (list_empty(&wdev->wpa_script_proc))
+			return 0;
+		wdev->wpa_kill_request = calloc(1, sizeof(*wdev->wpa_kill_request));
+		ubus_defer_request(ubus_ctx, req, wdev->wpa_kill_request);
+	}
 	return 0;
 }
 
 /* ubus callback network.wireless.notify, command = set_retry */
 static int
-wireless_device_set_retry(struct wireless_device *wdev, struct blob_attr *data)
+wireless_device_set_retry(struct wireless_device *wdev, struct blob_attr *data, bool ap)
 {
 	static const struct blobmsg_policy retry_policy = {
 		.name = "retry", .type = BLOBMSG_TYPE_INT32
@@ -1427,7 +1781,11 @@ wireless_device_set_retry(struct wireles
 	if (!val)
 		return UBUS_STATUS_INVALID_ARGUMENT;
 
-	wdev->retry = blobmsg_get_u32(val);
+	if(ap)
+		wdev->retry = blobmsg_get_u32(val);
+	else
+		wdev->wpa_retry = blobmsg_get_u32(val);
+
 	netifd_log_message(L_NOTICE, "Wireless device '%s' set retry=%d\n", wdev->name, wdev->retry);
 	return 0;
 }
@@ -1438,6 +1796,10 @@ enum {
 	NOTIFY_CMD_PROCESS_ADD = 2,
 	NOTIFY_CMD_PROCESS_KILL_ALL = 3,
 	NOTIFY_CMD_SET_RETRY = 4,
+	NOTIFY_CMD_WPAUP = 5,
+	NOTIFY_CMD_PROCESS_ADDWPA = 6,
+	NOTIFY_CMD_PROCESS_KILL_WPA = 7,
+	NOTIFY_CMD_SET_WPARETRY = 8,
 };
 
 /* ubus callback network.wireless.notify */
@@ -1494,6 +1856,13 @@ wireless_device_notify(struct wireless_d
 
 		wireless_device_mark_up(wdev);
 		break;
+	case NOTIFY_CMD_WPAUP:
+		if (vif)
+			return UBUS_STATUS_INVALID_ARGUMENT;
+		if (wdev->wpa_state != IFS_SETUP)
+			return UBUS_STATUS_PERMISSION_DENIED;
+		wireless_wpas_mark_up(wdev);
+		break;
 	case NOTIFY_CMD_SET_DATA:
 		if (vif)
 			pdata = &vif->data;
@@ -1512,11 +1881,17 @@ wireless_device_notify(struct wireless_d
 			wireless_vlan_set_data(vlan);
 		break;
 	case NOTIFY_CMD_PROCESS_ADD:
-		return wireless_device_add_process(wdev, cur);
+		return wireless_device_add_process(wdev, cur,true);
+	case NOTIFY_CMD_PROCESS_ADDWPA:
+		return wireless_device_add_process(wdev, cur, false);
 	case NOTIFY_CMD_PROCESS_KILL_ALL:
-		return wireless_device_process_kill_all(wdev, cur, req);
+		return wireless_device_process_kill_all(wdev, cur, req, true);
+	case NOTIFY_CMD_PROCESS_KILL_WPA:
+		return wireless_device_process_kill_all(wdev, cur, req, false);
 	case NOTIFY_CMD_SET_RETRY:
-		return wireless_device_set_retry(wdev, cur);
+		return wireless_device_set_retry(wdev, cur, true);
+	case NOTIFY_CMD_SET_WPARETRY:
+		return wireless_device_set_retry(wdev, cur, false);
 	default:
 		return UBUS_STATUS_INVALID_ARGUMENT;
 	}
@@ -1531,7 +1906,12 @@ wireless_start_pending(void)
 	struct wireless_device *wdev;
 
 	vlist_for_each_element(&wireless_devices, wdev, node)
-		__wireless_device_set_up(wdev, 0);
+	{
+		if (wdev->autostart)
+			__wireless_device_set_up(wdev);
+		if (wdev->wpa_autostart)
+			__wireless_wpas_set_up(wdev);
+	}
 }
 
 void wireless_device_hotplug_event(const char *name, bool add)
Index: netifd-2022-02-20-136006b8/wireless.h
===================================================================
--- netifd-2022-02-20-136006b8.orig/wireless.h
+++ netifd-2022-02-20-136006b8/wireless.h
@@ -60,6 +60,7 @@ struct wireless_device {
 	struct blob_attr *prev_config;
 	struct blob_attr *config;
 	struct blob_attr *data;
+	bool config_autostart;
 
 	bool autostart;
 	bool disabled;
@@ -70,6 +71,27 @@ struct wireless_device {
 	bool reconf;
 	bool cancel;
 	int retry;
+	
+	struct netifd_process wpa_script_task;
+	struct uloop_timeout wpa_timeout;
+	struct uloop_timeout wpa_poll;
+	
+	struct list_head wpa_script_proc;
+        struct uloop_fd wpa_script_proc_fd;
+        struct uloop_timeout wpa_script_check;
+
+        struct ubus_request_data *wpa_kill_request;
+
+        bool wpa_config_autostart;
+        bool wpa_autostart;
+
+        enum interface_state wpa_state;
+        enum interface_config_state wpa_config_state;
+        bool wpa_cancel;
+        int wpa_retry;
+
+        bool hostap_remove;
+        bool wpas_remove;	
 
 	int vif_idx;
 	int vlan_idx;
@@ -134,6 +156,14 @@ struct wireless_process {
 	bool keep;
 };
 
+enum wireless_config {
+       WDEV_TEARDOWN,
+       WDEV_SETUP,
+       WDEV_RELOAD,
+       WDEV_REPDOWN,
+       WDEV_REPUP,
+};
+
 void wireless_device_create(struct wireless_driver *drv, const char *name, struct blob_attr *data);
 void wireless_device_set_up(struct wireless_device *wdev);
 void wireless_device_set_down(struct wireless_device *wdev);
