--- a/include/linux/ieee80211.h
+++ b/include/linux/ieee80211.h
@@ -1955,6 +1955,7 @@ struct ieee80211_mu_edca_param_set {
 #define IEEE80211_VHT_CAP_TX_ANTENNA_PATTERN			0x20000000
 #define IEEE80211_VHT_CAP_EXT_NSS_BW_SHIFT			30
 #define IEEE80211_VHT_CAP_EXT_NSS_BW_MASK			0xc0000000
+#define IEEE80211_VHT_CAP_NOT_SUP_WIDTH_80                     0x80000000
 
 /**
  * ieee80211_get_vht_max_nss - return max NSS for a given bandwidth/MCS
--- a/net/mac80211/mlme.c
+++ b/net/mac80211/mlme.c
@@ -1727,11 +1727,20 @@ void ieee80211_recalc_ps(struct ieee8021
 		}
 		if (sdata->vif.type != NL80211_IFTYPE_STATION)
 			continue;
+#ifdef CPTCFG_WLAN_VENDOR_RWNX
+        if (!ieee80211_powersave_allowed(sdata)) {
+            count = 0;
+            break;
+        }
+#endif
 		found = sdata;
 		count++;
 	}
-
+#ifdef CPTCFG_WLAN_VENDOR_RWNX
+       if (count) {
+#else
 	if (count == 1 && ieee80211_powersave_allowed(found)) {
+#endif
 		u8 dtimper = found->u.mgd.dtim_period;
 
 		timeout = local->dynamic_ps_forced_timeout;
--- a/net/mac80211/rc80211_minstrel_ht.c
+++ b/net/mac80211/rc80211_minstrel_ht.c
@@ -194,8 +194,11 @@
 
 #define OFDM_GROUP __OFDM_GROUP(OFDM_GROUP_SHIFT)
 
-
-static bool minstrel_vht_only = true;
+#ifdef CPTCFG_WLAN_VENDOR_RWNX
+	static bool minstrel_vht_only = false;
+#else
+	static bool minstrel_vht_only = true;
+#endif
 module_param(minstrel_vht_only, bool, 0644);
 MODULE_PARM_DESC(minstrel_vht_only,
 		 "Use only VHT rates when VHT is supported by sta.");
@@ -1017,7 +1020,11 @@ minstrel_ht_update_stats(struct minstrel
 
 		/* (re)Initialize group rate indexes */
 		for(j = 0; j < MAX_THR_RATES; j++)
-			tmp_group_tp_rate[j] = MI_RATE(group, 0);
+#ifdef CPTCFG_WLAN_VENDOR_RWNX
+			tmp_group_tp_rate[j] = group * MCS_GROUP_RATES + ffs(mg->supported) - 1;
+#else
+			tmp_group_tp_rate[j] = group;
+#endif
 
 		if (group == MINSTREL_CCK_GROUP && ht_supported)
 			tp_rate = tmp_legacy_tp_rate;
@@ -1629,8 +1636,17 @@ minstrel_ht_update_caps(void *priv, stru
 				continue;
 
 			mi->supported[i] = mcs->rx_mask[nss - 1];
+#ifdef CPTCFG_WLAN_VENDOR_RWNX
+			if (mi->supported[i]) {
+				if (!n_supported++) {
+					mi->min_ridx = i * MCS_GROUP_RATES +
+						ffs(mi->supported[i]) - 1;
+				}
+			}
+#else
 			if (mi->supported[i])
 				n_supported++;
+#endif
 			continue;
 		}
 
@@ -1658,8 +1674,18 @@ minstrel_ht_update_caps(void *priv, stru
 		mi->supported[i] = minstrel_get_valid_vht_rates(bw, nss,
 				vht_cap->vht_mcs.tx_mcs_map);
 
+#ifdef CPTCFG_WLAN_VENDOR_RWNX
+               if (mi->supported[i]) {
+                       if (!n_supported++) {
+                               mi->min_ridx = i * MCS_GROUP_RATES +
+                                       ffs(mi->supported[i]) - 1;
+                       }
+               }
+#else
+
 		if (mi->supported[i])
 			n_supported++;
+#endif
 	}
 
 	minstrel_ht_update_cck(mp, mi, sband, sta);
--- a/net/mac80211/rc80211_minstrel_ht.h
+++ b/net/mac80211/rc80211_minstrel_ht.h
@@ -161,7 +161,9 @@ struct minstrel_ht_sta {
 
 	/* ampdu length (EWMA) */
 	unsigned int avg_ampdu_len;
-
+#ifdef CPTCFG_WLAN_VENDOR_RWNX
+	 u16 min_ridx;
+#endif
 	/* overall sorted rate set */
 	u16 max_tp_rate[MAX_THR_RATES];
 	u16 max_prob_rate;
--- a/net/mac80211/tx.c
+++ b/net/mac80211/tx.c
@@ -425,13 +425,19 @@ ieee80211_tx_h_multicast_ps_buf(struct i
 	if (ieee80211_is_probe_req(hdr->frame_control))
 		return TX_CONTINUE;
 
+#ifndef CPTCFG_WLAN_VENDOR_RWNX
 	if (ieee80211_hw_check(&tx->local->hw, QUEUE_CONTROL))
 		info->hw_queue = tx->sdata->vif.cab_queue;
-
+#endif
 	/* no stations in PS mode and no buffered packets */
 	if (!atomic_read(&ps->num_sta_ps) && skb_queue_empty(&ps->bc_buf))
 		return TX_CONTINUE;
 
+#ifdef CPTCFG_WLAN_VENDOR_RWNX
+       if (ieee80211_hw_check(&tx->local->hw, QUEUE_CONTROL))
+               info->hw_queue = tx->sdata->vif.cab_queue;
+#endif
+
 	info->flags |= IEEE80211_TX_CTL_SEND_AFTER_DTIM;
 
 	/* device releases frame after DTIM beacon */
@@ -623,6 +629,9 @@ ieee80211_tx_h_select_key(struct ieee802
 		case WLAN_CIPHER_SUITE_CCMP_256:
 		case WLAN_CIPHER_SUITE_GCMP:
 		case WLAN_CIPHER_SUITE_GCMP_256:
+#ifdef CPTCFG_WLAN_VENDOR_RWNX
+		case WLAN_CIPHER_SUITE_SMS4:
+#endif
 			if (!ieee80211_is_data_present(hdr->frame_control) &&
 			    !ieee80211_use_mfp(hdr->frame_control, tx->sta,
 					       tx->skb) &&
--- a/net/mac80211/util.c
+++ b/net/mac80211/util.c
@@ -3945,7 +3945,11 @@ u32 ieee80211_chandef_downgrade(struct c
 		/* freq_P40 */
 		c->center_freq1 = c->center_freq1 - 20 + 40 * tmp;
 		c->width = NL80211_CHAN_WIDTH_40;
+#ifdef CPTCFG_WLAN_VENDOR_RWNX
+		ret = 0;
+#else
 		ret = IEEE80211_STA_DISABLE_VHT;
+#endif
 		break;
 	case NL80211_CHAN_WIDTH_80P80:
 		c->center_freq2 = 0;
--- a/net/wireless/chan.c
+++ b/net/wireless/chan.c
@@ -1039,12 +1039,14 @@ bool cfg80211_chandef_usable(struct wiph
 			return false;
 		fallthrough;
 	case NL80211_CHAN_WIDTH_80:
-		prohibited_flags |= IEEE80211_CHAN_NO_80MHZ;
-		width = 80;
-		if (chandef->chan->band == NL80211_BAND_6GHZ)
-			break;
 		if (!vht_cap->vht_supported)
 			return false;
+#ifdef CPTCFG_WLAN_VENDOR_RWNX
+		if (vht_cap->cap & IEEE80211_VHT_CAP_NOT_SUP_WIDTH_80)
+			return false;
+#endif
+		prohibited_flags |= IEEE80211_CHAN_NO_80MHZ;
+		width = 80;
 		break;
 	case NL80211_CHAN_WIDTH_160:
 		prohibited_flags |= IEEE80211_CHAN_NO_160MHZ;
