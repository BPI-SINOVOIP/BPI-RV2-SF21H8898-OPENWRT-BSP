--- a/net/mac80211/util.c
+++ b/net/mac80211/util.c
@@ -2305,7 +2305,7 @@ int ieee80211_reconfig(struct ieee80211_
 	struct ieee80211_hw *hw = &local->hw;
 	struct ieee80211_sub_if_data *sdata;
 	struct ieee80211_chanctx *ctx;
-	struct sta_info *sta;
+	struct sta_info *sta, *tmp;
 	int res, i;
 	bool reconfig_due_to_wowlan = false;
 	struct ieee80211_sub_if_data *sched_scan_sdata;
@@ -2452,6 +2452,8 @@ int ieee80211_reconfig(struct ieee80211_
 
 		if (!ieee80211_sdata_running(sdata))
 			continue;
+		if(sdata->vif.type == NL80211_IFTYPE_AP_VLAN)
+			continue;
 
 		ieee80211_assign_chanctx(local, sdata);
 
@@ -2595,6 +2597,23 @@ int ieee80211_reconfig(struct ieee80211_
 			WARN_ON(drv_sta_state(local, sta->sdata, sta, state,
 					      state + 1));
 	}
+	
+	list_for_each_entry(sdata, &local->interfaces, list) {
+		if(sdata->vif.type == NL80211_IFTYPE_AP){
+			list_for_each_entry_safe(sta, tmp, &local->sta_list, list) {
+				if (sta->sdata->vif.type ==  NL80211_IFTYPE_AP_VLAN &&
+					sdata != sta->sdata &&
+					sdata->bss == sta->sdata->bss)
+				{
+					enum ieee80211_sta_state state;
+					pr_info("find ap_vlan-%s station\n",sta->sdata->name);
+					for (state = IEEE80211_STA_NOTEXIST;state < sta->sta_state; state++)
+						WARN_ON(drv_sta_state(local, sdata, sta, state, state + 1));
+				}
+			}	
+		}
+	}
+
 	mutex_unlock(&local->sta_mtx);
 
 	/* add back keys */
